"""
Enhanced logging configuration utility.
Provides dual logging (console + rotating file) with optional colorized console output.
Supports primary/verbose mode distinction and structured output with icons.
"""

from __future__ import annotations

import logging
import sys
from pathlib import Path
from logging.handlers import RotatingFileHandler
from typing import Optional
import re

# Optional color support for console output (falls back silently)
try:
    from colorama import init as colorama_init, Fore, Style  # type: ignore

    colorama_init()

    class _ColorFormatter(logging.Formatter):
        COLORS = {
            logging.DEBUG: Fore.CYAN,
            logging.INFO: Fore.GREEN,
            logging.WARNING: Fore.YELLOW,
            logging.ERROR: Fore.RED,
            logging.CRITICAL: Fore.MAGENTA,
        }

        def format(self, record: logging.LogRecord) -> str:  # noqa: D401
            color = self.COLORS.get(record.levelno, "")
            reset = Style.RESET_ALL if color else ""
            message = super().format(record)
            return f"{color}{message}{reset}"

except ImportError:  # pragma: no cover â€“ colorama optional

    class _ColorFormatter(logging.Formatter):
        """Fallback formatter without colors."""

        def format(self, record: logging.LogRecord) -> str:  # noqa: D401
            return super().format(record)


class StructuredFormatter(logging.Formatter):
    """Formatter that adds icons and structure to logging messages."""
    
    # Icons for different log types
    ICONS = {
        logging.DEBUG: "ðŸ”",
        logging.INFO: "â„¹ï¸",
        logging.WARNING: "âš ï¸",
        logging.ERROR: "âŒ",
        logging.CRITICAL: "ðŸš¨",
    }
    
    # Stage icons for better visual separation
    STAGE_ICONS = {
        "preprocessing": "ðŸ“",
        "generation": "âš¡",
        "validation": "ðŸš¦",
        "assembly": "ðŸ”§",
        "complete": "âœ”ï¸",
        "starting": "â–¶ï¸",
        "error": "âŒ",
        "success": "âœ…",
        "progress": "â³",
        "file": "ðŸ“",
        "model": "ðŸ¤–",
        "audio": "ã€°ï¸",
        "config": "âš™ï¸",
    }
    
    def __init__(self, fmt: str, use_icons: bool = True, verbose_mode: bool = False):
        super().__init__(fmt)
        self.use_icons = use_icons
        self.verbose_mode = verbose_mode
        
    def format(self, record: logging.LogRecord) -> str:  # noqa: D401
        # Only add icon if not already present in message
        if self.use_icons:
            message = record.getMessage()
            
            # Check if message already contains emoji/icon - comprehensive detection
            emoji_pattern = r'[âœ”ï¸âœ…âŒâš ï¸ðŸ”â„¹ï¸ðŸš¨ðŸ“âš¡ðŸš¦ðŸ”§â–¶ï¸â³ðŸ“ðŸ¤–ã€°ï¸âš™ï¸ðŸŽ¯ðŸš€ðŸ’¾ðŸŽµðŸ“ŠðŸŽ™ï¸ðŸ”„â­ï¸â™»ï¸ðŸ—‘ï¸âœ“ðŸ”„ðŸŽ›ï¸ðŸ’»]'
            has_emoji = bool(re.search(emoji_pattern, message))
            
            # Special handling for separator lines (lines with only = or - characters and whitespace)
            is_separator = re.match(r'^[=\-\s]*$', message.strip())
            
            # Special handling for structured lines (containing colons or phrases that suggest structure)
            is_structured = any(phrase in message for phrase in [
                "TTS PIPELINE", "EXECUTION PLAN", "TASK COMPLETED", "Job:", "Task:", "Label:", 
                "Execution time:", "Final stage:", "Final audio:", "Mode:", "Tasks:"
            ])
            
            if not has_emoji and not is_separator and not is_structured:
                # Add appropriate icon based on level
                level_icon = self.ICONS.get(record.levelno, "")
                
                # Add stage-specific icons for primary messages
                for keyword, stage_icon in self.STAGE_ICONS.items():
                    if keyword in message.lower() and not getattr(record, '_verbose_only', False):
                        level_icon = stage_icon
                        break
                
                # Apply icon with proper spacing
                if level_icon:
                    # Modify the args to prevent format issues with %s placeholders
                    if record.args:
                        # For f-string style messages with args, rebuild the message properly
                        formatted_message = record.getMessage()
                        record.msg = f"{level_icon} {formatted_message}"
                        record.args = None  # Clear args since message is now pre-formatted
                    else:
                        # For simple string messages
                        record.msg = f"{level_icon} {record.msg}"
                    
        return super().format(record)


class VerboseFilter(logging.Filter):
    """Filter to control verbose-only messages."""
    
    def __init__(self, verbose_mode: bool = False):
        super().__init__()
        self.verbose_mode = verbose_mode
        
    def filter(self, record: logging.LogRecord) -> bool:
        # Always allow warnings and errors
        if record.levelno >= logging.WARNING:
            return True
            
        # Check if message is marked as verbose-only
        if getattr(record, '_verbose_only', False):
            return self.verbose_mode
            
        # Always allow primary messages (INFO level without verbose marker)
        return True


def create_verbose_logger(name: str, verbose: bool = False) -> logging.Logger:
    """Create a logger with verbose support."""
    logger = logging.getLogger(name)
    
    # Add verbose method to logger
    def verbose(self, message, *args, **kwargs):
        if self.isEnabledFor(logging.INFO):
            self._log(logging.INFO, message, args, extra={'_verbose_only': True}, **kwargs)
    
    def primary(self, message, *args, **kwargs):
        if self.isEnabledFor(logging.INFO):
            self._log(logging.INFO, message, args, extra={'_verbose_only': False}, **kwargs)
    
    # Bind methods to logger
    import types
    logger.verbose = types.MethodType(verbose, logger)
    logger.primary = types.MethodType(primary, logger)
    
    return logger


class LoggingConfigurator:  # pylint: disable=too-few-public-methods
    """Central logging configuration helper with enhanced structure and verbose mode support.

    Usage:
        from utils.logging_config import LoggingConfigurator
        LoggingConfigurator.configure(log_file, verbose_mode=True)
    """

    @staticmethod
    def configure(
        log_file: Path,
        *,
        console_level: int = logging.INFO,
        file_level: int = logging.DEBUG,
        max_bytes: int = 5 * 1024 * 1024,
        backup_count: int = 3,
        append: bool = False,
        verbose_mode: bool = False,
        use_icons: bool = True,
    ) -> None:
        """Configure root logger with enhanced console and rotating file handler.

        Args:
            log_file: Target file path for detailed logs.
            console_level: Verbosity for console handler (default: INFO).
            file_level: Verbosity for file handler (default: DEBUG).
            max_bytes: Maximum size of each rotating log file.
            backup_count: Number of backup log files to keep.
            append: Append to existing log file instead of truncating.
            verbose_mode: Enable verbose mode for detailed logging.
            use_icons: Enable icons in console output.
        """
        # Ensure directory exists
        log_file.parent.mkdir(parents=True, exist_ok=True)

        root_logger = logging.getLogger()
        root_logger.setLevel(min(console_level, file_level))

        # Remove pre-existing handlers to avoid duplicate logs in interactive sessions
        for handler in root_logger.handlers[:]:
            root_logger.removeHandler(handler)

        # Console handler with structured formatting and verbose filtering
        if verbose_mode:
            console_fmt = "%(levelname)s - %(message)s"
        else:
            console_fmt = "%(message)s"  # Cleaner format for primary mode
            
        console_handler = logging.StreamHandler(sys.stdout)
        console_handler.setLevel(console_level)
        
        # Create structured formatter with color support
        class StructuredColorFormatter(_ColorFormatter, StructuredFormatter):
            def __init__(self, fmt: str):
                _ColorFormatter.__init__(self, fmt)
                StructuredFormatter.__init__(self, fmt, use_icons=use_icons, verbose_mode=verbose_mode)
                
            def format(self, record: logging.LogRecord) -> str:
                # Apply structure first, then color
                record = StructuredFormatter.format(self, record)
                return _ColorFormatter.format(self, record) if isinstance(record, logging.LogRecord) else record
        
        console_formatter = StructuredColorFormatter(console_fmt)
        console_handler.setFormatter(console_formatter)
        
        # Add verbose filter to console
        verbose_filter = VerboseFilter(verbose_mode=verbose_mode)
        console_handler.addFilter(verbose_filter)
        
        root_logger.addHandler(console_handler)

        # Structured log record factory: ensures optional context fields exist
        old_factory = logging.getLogRecordFactory()

        def _record_factory(*fa, **kwa):  # type: ignore
            record = old_factory(*fa, **kwa)
            # Ensure custom attributes exist to avoid formatting errors
            for attr in ("stage", "task", "job"):
                if not hasattr(record, attr):
                    setattr(record, attr, "-")
            return record

        logging.setLogRecordFactory(_record_factory)

        # Rotating file handler â€“ detailed, structured format (always verbose for files)
        file_fmt = (
            "%(asctime)s | %(levelname)-8s | %(job)s | %(task)s | %(stage)s | %(name)s | %(message)s"
        )
        file_mode = "a" if append else "w"
        file_handler: Optional[logging.Handler]
        try:
            file_handler = RotatingFileHandler(
                log_file,
                mode=file_mode,
                maxBytes=max_bytes,
                backupCount=backup_count,
                encoding="utf-8",
            )
        except Exception:  # pragma: no cover â€“ cannot instantiate
            # Fallback to simple FileHandler if rotating fails for platform reasons
            file_handler = logging.FileHandler(log_file, mode=file_mode, encoding="utf-8")

        file_handler.setLevel(file_level)
        file_handler.setFormatter(logging.Formatter(file_fmt))
        root_logger.addHandler(file_handler)

        # Configure third-party library logging
        LoggingConfigurator._configure_third_party_logging(verbose_mode)
        
        # Set development mode to verbose by default
        if verbose_mode:
            # Enable DEBUG level for our modules
            for module_name in ['generation', 'validation', 'chunking', 'postprocessing', 'utils']:
                module_logger = logging.getLogger(module_name)
                module_logger.setLevel(logging.DEBUG)

    @staticmethod
    def _configure_third_party_logging(verbose_mode: bool = False) -> None:
        """Configure third-party library logging levels."""
        
        # Always reduce noisy third-party libraries
        noisy_libs = [
            "urllib3", "matplotlib", "PIL", "requests", "transformers.tokenization_utils",
            "transformers.configuration_utils", "transformers.modeling_utils"
        ]
        
        for lib in noisy_libs:
            logging.getLogger(lib).setLevel(logging.WARNING)
        
        # Completely silence numba bytecode dumps (as requested)
        logging.getLogger("numba.core.byteflow").setLevel(logging.CRITICAL)
        logging.getLogger("numba").setLevel(logging.WARNING)
        
        # Additional ChatterboxTTS/HuggingFace noise reduction
        if not verbose_mode:
            logging.getLogger("transformers").setLevel(logging.WARNING)
            logging.getLogger("torch").setLevel(logging.WARNING)
            logging.getLogger("torchaudio").setLevel(logging.WARNING)


def get_logger(name: str, verbose: bool = False) -> logging.Logger:
    """Get a logger with verbose support.
    
    Args:
        name: Logger name (typically __name__)
        verbose: Whether verbose mode is enabled
        
    Returns:
        Logger with verbose() and primary() methods
    """
    return create_verbose_logger(name, verbose) 