In einem Task-Verzeichnis unterhalb eines Job-Verzeichnisses, wie zum Beispiel "data/output/raise_children/raise_children_mike_20250618_061557" liegt im Unterordner "data/output/raise_children/raise_children_mike_20250618_061557/final/" nach Abschluss eines vollständig gelaufenenen Tasks eine Metadaten JSON Datei die Informationen über den Task speichert. Siehe passend dazu z.B. "data/output/raise_children/raise_children_mike_20250618_061557/final/raise_children_mike_final_metadata.json". Diese enthält als Task-Daten auch die für das Audio-Assembly schlussendlich ausgewählten "Best Candidates" der mehrfach berechneten Audio-Chunks. In diesem Objekt "selected_candidates": {
    "0": 0,
    "1": 2,
    "2": 1,
    "3": 1, ... }. In diesem Beispiel-Task hier wurden seineerzeit für jeden Chunk 5 Audio-Kandidaten errechnet, und ggfs., noch zwei weitere Retry-Kanidaten, also maxmimal 7 Kanidaten. Bemerke, daß intern im Code die Chunk-Zählung meist bei Null beginnend geführt wird, während User-Facing oft korrigiert zu 1-geginnende Chunk-Zählung angezeigt wird). Hier im Beispiel in der selected_candidates-Liste, wurde also für den ersten Text-Chunk '"0": 0', der Audio-Kanditat 0 (also "data/output/raise_children/raise_children_mike_20250618_061557/candidates/chunk_001/candidate_01.wav") ausgewählt. Und für chunk_002 ("1": 2) wurde der Audio-Kandidate 3 eingefügt ("data/output/raise_children/raise_children_mike_20250618_061557/candidates/chunk_001/candidate_03.wav") , usw.

Ich glaube diese ...final_metadata.json wird ziemlich am Ende einer Laufzeit für einen fast fertigen Task erzeugt, dann, wenn auch die finale Audio-Datei aus den Chunks zusammengefügt wird.

Alternativ sind die dieselben "selected_candidates"-Daten auch schon zu einem früheren Zeitpunkt, nämlich NACH der Validierung und findung der Best Candidates verfügbar, denn sie werden bereits in der "data/output/raise_children/raise_children_mike_20250618_061557/enhanced_metrics.json" Datei gespeichert. Das ist super, das diese Information zweimal gespeichert vorlieget. Denn ich möchte diese Auswahl des Besten Kandidaten für den User editierbar achen. So könnten die Daten in der enhanced_metrics.json-Datei im task-Verzeichnis super dazu dienen die Auswahl der Kandidaten durch den User zu speichern/managen, und im /final/ Ordner die ...final_metadata.json würde die getroffene Auswahl die für diese final-Audio-Version zur Verwendung kam endspeichern (aber unveränderlich sein).

Die "selected_canidates"-Liste in enhanced_metrics.json möchte ich verwenden, um einen neuen User-Interface-Pfad einzufügen, einen Task-Editor, damit der User nachträglich die ausgewählten Candidates ändern kann, und die finale Audio-Datei mit anderen Kandidaten (als den vom Prohgramm gewählten "best candidates") neu assemblieren zu können. 

Wo soll die Abfrage des Users zum Ändern der Kandidaten, der task-Editor, eingebaut werden? – Im zweiten Prompt von main. Zum Beispiel: Der User ruft mit "python src/main.py --j "raise_children"" einen Job auf.
Der erste Prompt (hier bereits liecht angepasst und geändert) fragt:

'''
==================================================
TTS PIPELINE - TASK-BASED EXECUTION SYSTEM
==================================================
Using device: cuda

Found existing tasks for job 'raise_children':
1. raise_children - mike - raise_children.txt - 18.06.2025 - 06:15 (<-- latest)

Select action:
[Enter] - Select latest task for options
1-1     - Select specific task for options
n       - Create new task
a       - Run all tasks (Check tasks if needs resuming)
ln      - Run latest task + force new final audio
an      - Run all tasks + force new final audio
c       - Cancel". 

>1
'''

Der User wählte N einen Specific Task oder Enter. Es geht zum zweiten Prompt.

Hier müsste das Verhalten geändert werden. Bisher hat das Programm hier noch nichts getan und hat nur einfach die 2. Nachfrage gestartet, um abzugragen, was getan werden soll. 
Alter zweiter Prompt:
'''
Selected latest task: raise_children - 18.06.2025 06:15

"What to do with this task?
[Enter] - Run task (Check task if needs resuming)
n      - Run task (repair if necessary) + force new final audio
c      - Cancel" 
'''

Also früher (im momentanten Zustand des Codes) hat es nach "[Enter] Run Task" den Task-Zustand eingeholt, geprüft ob eine Final-Audio exisitert. Und wenn keine finale Audio Datei existiert (nicht "complete", wurden auch das Vorhandensein der Audio-Chunks und Text-Chunks geprüft, und alle möglichen Zustände etc... Dasselbe passierte bei der Option "n" – wobei dann die Final-Audio-Datei ignoriert wurde, und aber dennoch bei vollständigkeit der Audio-Chunks eine neues finales Audio geneiert. Aber das nur für den Kontext.


Nun soll das Programm aber proaktiv  die Überprüfung des Task-Zustandes einholen, damit dem zweiten Prompt die notwendigen Informationen für den User zur Verfügung stehen – In welches Zustand befindet sich der Task? 
also ob eine Finale Audio-Datei und eine "...final_metadata.json" und eine "enhanced_metrics.JSON" vorliegt oder nicht, oder ob Kandidaten fehlen und aufgefült werden müssen, oder in welchem Zustand der Task sonst ist. Das ist ein Schritt, den wir eigentlich sonst erst später gemacht haben, nach der Auflösung des zweiten Prompts. Mit diesen Informationen über den Task-Zustand kann der Prompt kann smartere Optionen anbieten: Nämlich ein neues Feature: "user_candidate_editor". Die Option für "e" - Edit Task braucht nur dann verfügbar sein, wenn die "best candidate selection" aus der Whisper-Validierung in der enhanced_metrics.JSON Datei im Task-Verzeichnis vorliegt. Ansonsten müsste sie "N/A" lauten. Der zweite Prompt, nenen wir ihn "Task-Prompt", ähnlich wie bisher würde dann anbieten:

'''
Selected latest task: raise_children - 18.06.2025 06:15

Task state: {task state}

[Task is rendered complete and final audio is available.(Has no missing files, state is complete and final audio and candidate selection is present)|Task is complete with final audio but is missing some candidates and should be re-assembled(has Missing candidates, even though final audio and candidate selection present)|Task is incomplete and needs to finish. (any other state, like missing chunks, candidates, validation etc., and no final audio and candidate selection present)]

What to do with this task?
[Enter] - Run task, fill gaps, create new final audio.
r       - Run task, fill gaps, dont't overwrite existing final audio.
n       - Run task, re-render all candidates(!), create new final audio)
N/A     - (Edit comleted task - choose different candidates) *greyed out?*
e       - Edit completed task - choose different candidates
c       - Cancel" 

> e
'''

Der User verwendet "e".
Ein dritter Prompt erscheint – ein "user_candidate_editor".

'''
Selected latest task: raise_children - 18.06.2025 06:15

Candidates selected as best matching for the final audio assembly:

Chunk:  Cand.:  Text:
1       1       "Column. Raise Children to Life, not to War. ..."
2       3       "Seven years had passed since the miraculous ..."
3       2       "he event on October 4th was one of many  ..."
4       2       "Introduction ends. On October 7th, I arrive..."
5       5       "My friend Michal Halev flew to Israel to ..."
...usw...

Which Chunk would you like to edit/review?:
1-34    - Select chunk
c       - Return

>1
'''

Der User wählt "1", um den ersten Chunk zu ändern.
Es erscheint der nächste Prompt – der "user_candidate_selector":

'''
Selected latest task: raise_children - 18.06.2025 06:15

Select audio candidate for chunk: 001/034

Text: "Column. Raise Children to Life, not to War. A text by Yael Deckelbaum. Sixteenth February 2024. Introduction. On October 4th, three days before the war broke out, I sang "Prayer of the Mothers" in a joint event of the Israeli Women Wage Peace and the Palestinian "Women of the Sun", two peace organizations led by women from two enemy nations."

Number of candidates: {total_candidates}
Current selected Candidate: 1

Candidate:  exageration:    cfg_weight  temp    type        sim_score   length_score    qty_score   passed
1 <- sel    0.4             0.2         0.9     EXPRESSIVE  0.72        .97             0.83        ✅
2           0.35            0.25        0.96    EXPRESSIVE  0.63        .97             0.78        ❌
3           0.35            0.25        0.96    EXPRESSIVE  0.63        .97             0.78        ❌
...

Select action:
1-5     - Select candidate
c       - Return

> 3
'''

Der User wählte Kandidat 3:
Die neue Wahl für Chunk 1 mit Kandidat 3 wird sofort in die enhanced_metrics.JSON-Datei im Task-Verzeichnis eingetragen. "data/output/raise_children/raise_children_mike_20250618_061557/enhanced_metrics.json", als dauerhaft neuer selected_candidate:

...
"selected_candidates": {
    "0": 2,  <---- hier eingetragen
    "1": 2,
    "2": 1,
    "3": 1, 
...

Das CLI bleibt im user_candidate_selector Prompt. Aber in der Liste wird die Änderung, die User-Auswahl, durch "<- sel" angezeigt.

'''
Selected latest task: raise_children - 18.06.2025 06:15

Select audio candidate for chunk: 001/034

Text: "Column. Raise Children to Life, not to War. A text by Yael Deckelbaum. Sixteenth February 2024. Introduction. On October 4th, three days before the war broke out, I sang "Prayer of the Mothers" in a joint event of the Israeli Women Wage Peace and the Palestinian "Women of the Sun", two peace organizations led by women from two enemy nations."

Number of candidates: {total_candidates}
Current selected Candidate: 1

Candidate:  exageration:    cfg_weight  temp    type        sim_score   length_score    qty_score   passed
1           0.4             0.2         0.9     EXPRESSIVE  0.72        .97             0.83        ✅
2           0.35            0.25        0.96    EXPRESSIVE  0.63        .97             0.78        ❌
3 <- sel    0.35            0.25        0.96    EXPRESSIVE  0.63        .97             0.78        ❌
...

Select action:
1-5     - Select candidate
c       - Return

> c
'''

Der User wählte c - Return.
Es geht zurück zum user_candidate_editor Prompt. Änderungen werden auch hier fur den User nochmal ersichtlich durch ein hinzugefügtes "(changed)" bei durch den User geänderten Kandidaten. (Abgleich eines internen Backup-Zwischenspeichers der Daten vorher mit dem aktuellen Zustand der Daten nach der Änderung):

'''
Selected latest task: raise_children - 18.06.2025 06:15

Candidates selected as best matching for the final audio assembly:

Chunk:  Cand.:      Text:
1       3(changed)  "Column. Raise Children to Life, not to War. ..."
2       3           "Seven years had passed since the miraculous ..."
3       2           "he event on October 4th was one of many  ..."
4       2           "Introduction ends. On October 7th, I arrive..."
5       5           "My friend Michal Halev flew to Israel to ..."
...usw...

Which Chunk would you like to edit?:
1-34    - Select chunk
r       - Rerun task, re-assemble final audio from chunks
c       - Return

>r 
'''

Der User wählte r - Rerun task, re-assemble final audio from chunks.

Sofort wird der Task ausgeführt mit den neuen custom Kandidaten-Selektionen des Users. Weil alle Audio-Chunks vorliegen, wird nun ein neues final Audio mit einer anderen Zusammensetzung von Chunks generiert. (Background-Kontext: Der User hatte außerhalb des Programms die Chunks einzeln abgespielt und probegheört und sich für bessere Chunks mit fehlerfreierer Aussprache entschieden).

Das Programm läuft nun genauso weiter als hätte der User wie bisher im ersten Task-Prompt "Use latest task + force new final audio" bzw. das neu "Run task, fill gaps, create new final audio." gewählt. Der User hätte genauso auch c - Return wählen können, um zum Task-Prompt zurückzukehren und im Task-Prompt selbst "[ENTER] - Run task, fill gaps, create new final audio" anstoßen können. Das Programm sollte in diesem Fall auch das Re-Assembly entsprechend der geänderten Kandiaten-Configuration in der enahnced_metrics.JSON durchführen. 
 
