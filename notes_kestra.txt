https://kestra.io/docs/tutorial/fundamentals

YAML- and Python based, file-driven (not database driven), scalable, adaptable workflow orchestration tool. All can be done in code or in UI! (Easy for me to follow and manage). But its still very CLI-centric. 

Kestra is an open-source workflow orchestration platform that allows you to define workflows declaratively in YAML files, with an easy UI.

Workflows can be version-controlled, easily edited, and managed without the need for a database-driven backend for workflow definitions.

Kestra supports event-based triggers, scheduling, and integrates well with a wide variety of systems, making it suitable for TTS pipelines and similar job-based architectures.

The platform emphasizes simplicity, collaboration, and reduced maintenance, with workflows stored as human-readable YAML files.

Customizing the Kestra UI for Minimal, Predefined Workflows
1. Built-in UI Customization with Apps for deploying a fixed, minimal interface for a specific workflow or set of workflows.IS possible but is only available in the enterprice plan. Not free. However one can use UI Frameworks like Gradio or Chakra to custom build minimal workflow-specifik Interfaces which would work with Kestra-API.  A few more notes below.


Processing data
For basic data processing, you can leverage Kestra's Pebble templating engine.

Processing data using scripts
Kestra can launch scripts written in Python, R, Node.js, Shell and Powershell. Depending on the runner, they can run directly in a local process on the host or inside Docker containers.

Those script tasks are available in the Scripts Plugin. Below is documentation for each of them:

The Python task runs a Python script in a Docker container or in a local process.
The Node task runs a Node.js script in a Docker container or in a local process.
The R task runs an R script in a Docker container or in a local process.
The Shell task executes a single Shell command, or a list of commands that you provide.
The PowerShell task executes a single PowerShell command, or a list of commands that you provide.

Kestra offers several plugins for ingesting and transforming data.

Replays are extremely useful for iterative development and reprocessing data. The replay feature allowed you to re-run a failed task with the corrected version of the flow code. You didn't have to rerun tasks that had already completed successfully. This is a huge time-saver when iterating on your workflows.

Pebble ​Templating ​Engine
Dynamically render variables, inputs and outputs.

Pebble is a Java templating engine inspired by Twig and similar to the Python Jinja Template Engine syntax. Kestra uses it to dynamically render variables, inputs, and outputs within the execution context.

Dynamically render a task with TemplatedTask
Since Kestra 0.16.0, you can use the TemplatedTask task to fully template all task properties using Pebble. This way, all task properties and their values can be dynamically rendered based on your custom inputs, variables, and outputs from other tasks.

Parsing objects & lists using jq
Sometimes, outputs return nested objects or lists. To parse those elements, you may leverage jq. You can use jQuery to slice, filter, map, and transform structured data with the same ease that sed, awk, grep, and similar Linux commands let you manipulate strings.

Overview
Kestra's workflows are stateless by design. All workflow executions and task runs are isolated from each other by default to avoid any unintended side effects. When you pass data between tasks, you do so explicitly by passing outputs from one task to another, and that data is stored transparently in Kestra's internal storage. This stateless execution model ensures that workflows are idempotent and can be executed anywhere in parallel at scale.

However, in certain scenarios, your workflow might need to share data beyond passing outputs from one task to another. For example, you might want to persist data across executions or even across different workflows. This is where the Key Value (KV) store comes into play.

KV Store allows you to store any data in a convenient key-value format. You can create them directly from the UI, via dedicated tasks, Terraform, or through the API.

UI: How to Create, Read, Update and Delete KV pairs from the UI
Kestra follows a philosophy of Everything as Code and also from the UI. Therefore, you can create, read, update, and delete KV pairs both from the UI and Code.

Flows are versioned by default. Whenever you make any changes to your flows, a new revision is created. This allows you to rollback to a previous version of your flow if needed.

If you navigate to a specific flow and go to the Revisions tab, you will see a list of all revisions of that flow. You can then compare the differences between two revisions side-by-side or line-by-line and rollback to a previous revision if needed.

_________
UI

UI Configuration:
The open-source Kestra UI allows for some per-user customization, such as default namespaces, editor type (YAML or no-code), log display preferences, theme (light/dark), font size, and other minor settings. These adjustments can make the interface more comfortable but do not fundamentally change the workflow-centric layout or hide features to create a minimal, workflow-specific experience.

Workflow-Focused Experience:
You can organize your flows and use the UI to focus on a particular namespace or set a default flow tab, but you cannot restrict the UI to display only a single workflow or hide other Kestra features for a truly minimal, guided experience.

Custom UI Development:
If you require a highly tailored UI for a specific workflow (for example, a single-page app that only triggers and displays the results of one flow), you would need to build a lightweight custom frontend that interacts with the Kestra API. The open-source edition does not provide a rapid, built-in framework for custom UIs beyond the standard dashboard and settings.

How Integration Can Work
You can create a Gradio UI that acts as a frontend, allowing users to submit data or parameters. The backend logic in your Gradio app can then trigger a Kestra flow via Kestra’s REST API, passing user inputs as parameters. Once the Kestra job completes, your Gradio app can fetch the results (using the Kestra API) and display them to the user.

Example Integration Pattern
User interacts with Gradio UI (inputs text, uploads file, etc.).
Gradio backend function sends a REST API request to start a Kestra flow with the user’s input.
Gradio polls Kestra (or uses a callback mechanism) to check job status and retrieve results.
Gradio displays the results in the web UI.

This pattern is similar to how Gradio is used as a frontend for other backend services or APIs.

References and Further Reading
Kestra’s YouTube guide shows how to run Python code and pass values/files in workflows, which is useful if you want Kestra to call a Python script that launches a Gradio app.
